---
title: Flash Accounting
---

# Flash Accounting

In previous versions of Uniswap, every time a swap was made - including multi-hop swap - tokens were transferred between Pool contracts for intermediate steps.

This design led to inefficiencies because moving tokens around by calling external functions on their smart contracts - especially in a multi-hop swap - was quite expensive. But also, this was the only design possible since each pool was it's own contract and we needed to move tokens in and out of them to keep the logic sound.

With the singleton architecture, a better design now exists - this is called Flash Accounting(hereinafter FA). It is made even more efficient after the introduction of [Transient Storage](https://eips.ethereum.org/EIPS/eip-1153). FA further reduces the gas cost of trades that cross multiple pools and supports more complex integrations with Uniswap v4.

With FA, tokens are moved into the `PoolManager` and each operation (e.g. swap and liquidity modification) conducted in `PoolManager` updates an internal net balance known as `delta`, **only the final output tokens need to be withdrawn out of the** `PoolManager`.

## Deltas

### Locking 

To ensure correctness and atomicity in complex operations like a multi-hop swap - v4 uses a locking mechanism. Anytime key actions need to take place within the `PoolManager` - e.g. swaps and liquidity modification - a periphery contract must `unlock` the `PoolManager` first. Then integrators implement the `unlockCallback` and proceed with any of the following actions on the pools:

- swap
- modifyLiquidity
- donate
- take
- settle
- mint
- burn

Note that pool initialization can happen outside the context of unlocking the `PoolManager`.

### Balance Delta

Inside `unlockCallback`, the periphery contract does whatever it needs to do, conduct swaps, modify positions, etc - and finally returns a result. At this point, the `PoolManager` checks to make sure all balances have been settled - and nothing is owed to or from the `PoolManager`. If all looks good, it locks again.

The balances settled above is what we refer as the `delta`, a field held in the unlock state i.e. **debits and credits of assets from the `PoolManager`**. 

Once the `PoolManager` is unlocked, it starts with a blank slate. Then, the user may send the `PoolManager` some tokens for a swap to happen, and this creates a debit to the `PoolManager`. The swap logic is run, which then sends tokens back to the user, creating a credit to the `PoolManager`. In case of a multi-hop swap, multiple more debits and credits can be created here. But at the end, when the `unlockCallback` returns - **the net `delta` must be zero, i.e. no pending debits or credits**, and then only will the transaction succeed. This unlock and call style architecture gives callers maximum flexibility in integrating with the core code.

## Swapping

![Multi-hop swaps on V3 vs V4](https://lh7-us.googleusercontent.com/sE7quPXvlU_AKTzNWiB2aYSmlO9gbjJyHRyQyx0ljMiFTVNaxb2WZ4Zlbe1l0C25vHO-Y-3y_zQeXJYVXCYxvNWPYX4nOC6JSSOeDPzx6bqoqT74-IpBMLq7miNl3yXbgU7EE_U6tuRzpPN5JsWQWA4oKg=s2048)

As shown in the above diagram, for example - let's say you wanted to swap `ETH` for `DAI`. Assuming this requires a multi-hop swap going from `ETH` to `USDC` and then from `USDC` to `DAI`.

### Previously on v3

1. `ETH` is sent to `ETH <> USDC` pool contract

2. `USDC` is withdrawn from `ETH <> USDC` contract and sent to `USDC <> DAI` contract

3. `DAI` is withdrawn from `USDC <> DAI` contract and sent to user

### Now on v4

1. `ETH` is sent to `PoolManager`

2. `PoolManager` calculates `USDC` output amount

3. Without transferring tokens, `PoolManager` calculates `DAI` output amount for `USDC` → `DAI` swap

4. `DAI` is withdrawn and sent to user

Therefore we can skip the step of actually calling `transfer()` on the USDC contract. 

This same logic also scales further to **any swap with an arbitrary number of hops required, and the number of actual token transfers remains constant**.

## Liquidity Management

The optimization becomes more evident if we conduct complex liquidity operations with the help of hooks.

For example - let's say you wanted to add liquidity to `ETH <> DAI` but you have no DAI so you have to swap some `ETH` to `DAI` in order to add liquidity with both tokens. Assuming this requires a multi-hop swap going from `ETH` to `USDC` and then from `USDC` to `DAI`.

### Previously on v3

1. Some `ETH` is sent to `ETH <> USDC` pool contract

2. `USDC` is withdrawn from `ETH <> USDC` contract and sent to `USDC <> DAI` contract

3. `DAI` is withdrawn from `USDC <> DAI` contract and sent to user

4. Both `ETH` and `DAI` are sent to `ETH <> DAI` pool contract to add liquidity

Without FA, this would cost a considerable amount of gas due to external contracts calls and overhead on handling custom `transfer` logic with different tokens.

### Now on v4

1. `ETH` is sent to `PoolManager`

2. During `modifyLiquidity()`, `PoolManager` detects a hook that has `beforeAddLiquidity` permission on `ETH <> DAI` pool contract

3. Without transferring tokens, `PoolManager` calculates `USDC` output amount for `ETH` → `USDC` swap

4. Without transferring tokens, `PoolManager` calculates `DAI` output amount for `USDC` → `DAI` swap

4. Both `ETH` and `DAI` are sent to `ETH <> DAI` pool contract to add liquidity

We can skip the step of actually calling `transfer()` on USDC contract, and Transient Storage improves gas efficiency by removing the necessity to require storage updates at every balance change.

## Developer resources
To see how unlock callback and delta work in a smart contract read [Unlock Callback & Deltas](/contracts/v4/guides/unlock-callback).